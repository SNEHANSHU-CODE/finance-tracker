// models/reportModel.js
const mongoose = require('mongoose');

const reportSchema = new mongoose.Schema({
  profileId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Profile',
    required: [true, 'Profile ID is required'],
    index: true
  },
  reportType: {
    type: String,
    required: [true, 'Report type is required'],
    enum: [
      'monthly_expense',
      'quarterly_budget',
      'savings_goal_analysis',
      'income_analysis',
      'expense_report',
      'budget_performance',
      'goal_progress',
      'cash_flow',
      'net_worth',
      'custom'
    ]
  },
  title: {
    type: String,
    required: [true, 'Report title is required'],
    trim: true,
    maxlength: [100, 'Title cannot exceed 100 characters']
  },
  description: {
    type: String,
    maxlength: [500, 'Description cannot exceed 500 characters']
  },
  period: {
    startDate: {
      type: Date,
      required: [true, 'Start date is required']
    },
    endDate: {
      type: Date,
      required: [true, 'End date is required']
    },
    periodType: {
      type: String,
      enum: ['Daily', 'Weekly', 'Monthly', 'Quarterly', 'Yearly', 'Custom'],
      default: 'Monthly'
    }
  },
  data: {
    // Summary data
    totalIncome: {
      type: Number,
      default: 0
    },
    totalExpenses: {
      type: Number,
      default: 0
    },
    netSavings: {
      type: Number,
      default: 0
    },
    savingsRate: {
      type: Number,
      default: 0
    },
    
    // Category breakdown
    categoryBreakdown: [{
      category: String,
      amount: Number,
      percentage: Number,
      transactionCount: Number
    }],
    
    // Budget analysis
    budgetAnalysis: [{
      category: String,
      budgetAmount: Number,
      spentAmount: Number,
      remainingAmount: Number,
      utilizationPercentage: Number,
      status: String
    }],
    
    // Goal progress
    goalProgress: [{
      goalId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Goal'
      },
      goalName: String,
      targetAmount: Number,
      savedAmount: Number,
      progressPercentage: Number,
      daysRemaining: Number,
      status: String
    }],
    
    // Trends and insights
    trends: {
      incomeGrowth: Number,
      expenseGrowth: Number,
      savingsGrowth: Number,
      topSpendingCategory: String,
      largestExpense: {
        description: String,
        amount: Number,
        date: Date
      },
      averageDailySpending: Number
    },
    
    // Custom metrics for custom reports
    customMetrics: [{
      label: String,
      value: mongoose.Schema.Types.Mixed,
      type: {
        type: String,
        enum: ['number', 'percentage', 'currency', 'text']
      }
    }]
  },
  insights: [{
    type: {
      type: String,
      enum: ['positive', 'negative', 'neutral', 'warning']
    },
    title: String,
    message: String,
    recommendation: String
  }],
  status: {
    type: String,
    enum: ['Generated', 'Scheduled', 'Failed', 'Archived'],
    default: 'Generated'
  },
  generatedAt: {
    type: Date,
    default: Date.now
  },
  scheduledFor: {
    type: Date
  },
  isAutoGenerated: {
    type: Boolean,
    default: false
  },
  settings: {
    includeCharts: {
      type: Boolean,
      default: true
    },
    includeTrends: {
      type: Boolean,
      default: true
    },
    includeInsights: {
      type: Boolean,
      default: true
    },
    includeRecommendations: {
      type: Boolean,
      default: true
    },
    chartTypes: [{
      type: String,
      enum: ['pie', 'bar', 'line', 'donut', 'area']
    }]
  },
  tags: [{
    type: String,
    trim: true,
    maxlength: [20, 'Tag cannot exceed 20 characters']
  }],
  isShared: {
    type: Boolean,
    default: false
  },
  shareToken: {
    type: String,
    unique: true,
    sparse: true
  }
}, {
  timestamps: true
});

// Indexes for better performance
reportSchema.index({ profileId: 1, createdAt: -1 });
reportSchema.index({ profileId: 1, reportType: 1 });
reportSchema.index({ profileId: 1, 'period.startDate': 1, 'period.endDate': 1 });
reportSchema.index({ shareToken: 1 }, { sparse: true });

// Virtual for report duration in days
reportSchema.virtual('durationDays').get(function() {
  const diffTime = this.period.endDate - this.period.startDate;
  return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
});

// Virtual for formatted period
reportSchema.virtual('formattedPeriod').get(function() {
  const start = this.period.startDate.toLocaleDateString();
  const end = this.period.endDate.toLocaleDateString();
  return `${start} - ${end}`;
});

// Method to generate share token
reportSchema.methods.generateShareToken = function() {
  this.shareToken = require('crypto').randomBytes(16).toString('hex');
  this.isShared = true;
  return this.save();
};

// Method to revoke share access
reportSchema.methods.revokeShare = function() {
  this.shareToken = undefined;
  this.isShared = false;
  return this.save();
};

// Method to add insight
reportSchema.methods.addInsight = function(type, title, message, recommendation) {
  this.insights.push({ type, title, message, recommendation });
  return this.save();
};

// Static method to get reports by profile and type
reportSchema.statics.getByProfileAndType = function(profileId, reportType, limit = 10) {
  const query = { profileId };
  if (reportType) query.reportType = reportType;
  
  return this.find(query)
    .sort({ createdAt: -1 })
    .limit(limit);
};

// Static method to get reports by period
reportSchema.statics.getByPeriod = function(profileId, startDate, endDate) {
  return this.find({
    profileId,
    'period.startDate': { $gte: new Date(startDate) },
    'period.endDate': { $lte: new Date(endDate) }
  }).sort({ createdAt: -1 });
};

// Static method to get scheduled reports
reportSchema.statics.getScheduled = function() {
  return this.find({
    status: 'Scheduled',
    scheduledFor: { $lte: new Date() }
  });
};

// Static method to create monthly expense report
reportSchema.statics.createMonthlyExpenseReport = async function(profileId, month, year) {
  const Transaction = mongoose.model('Transaction');
  const Budget = mongoose.model('Budget');
  
  const startDate = new Date(year, month - 1, 1);
  const endDate = new Date(year, month, 0, 23, 59, 59);
  
  // Get monthly summary from Transaction model
  const summary = await Transaction.getMonthlySummary(profileId, month, year);
  
  // Get budget analysis
  const budgets = await Budget.find({ profileId, month, year, isActive: true });
  const budgetAnalysis = budgets.map(b => ({
    category: b.category,
    budgetAmount: b.budgetAmount,
    spentAmount: b.spentAmount,
    remainingAmount: b.remainingAmount,
    utilizationPercentage: b.utilizationPercentage,
    status: b.status
  }));
  
  // Create category breakdown
  const categoryBreakdown = Object.entries(summary.categoryBreakdown).map(([category, amount]) => ({
    category,
    amount,
    percentage: summary.totalExpenses > 0 ? (amount / summary.totalExpenses) * 100 : 0,
    transactionCount: 0 // This would need to be calculated separately
  }));
  
  const report = new this({
    profileId,
    reportType: 'monthly_expense',
    title: `Monthly Expense Report - ${new Date(year, month - 1).toLocaleString('default', { month: 'long', year: 'numeric' })}`,
    description: `Detailed analysis of expenses for ${new Date(year, month - 1).toLocaleString('default', { month: 'long', year: 'numeric' })}`,
    period: {
      startDate,
      endDate,
      periodType: 'Monthly'
    },
    data: {
      totalIncome: summary.totalIncome,
      totalExpenses: summary.totalExpenses,
      netSavings: summary.netSavings,
      savingsRate: summary.savingsRate,
      categoryBreakdown,
      budgetAnalysis,
      trends: {
        averageDailySpending: summary.averageDaily
      }
    },
    isAutoGenerated: true
  });
  
  return report.save();
};

// Static method to create budget performance report
reportSchema.statics.createBudgetPerformanceReport = async function(profileId, month, year) {
  const Budget = mongoose.model('Budget');
  
  const startDate = new Date(year, month - 1, 1);
  const endDate = new Date(year, month, 0, 23, 59, 59);
  
  const summary = await Budget.getBudgetSummary(profileId, month, year);
  const efficiency = await Budget.getBudgetEfficiency(profileId, month, year);
  
  const report = new this({
    profileId,
    reportType: 'budget_performance',
    title: `Budget Performance Report - ${new Date(year, month - 1).toLocaleString('default', { month: 'long', year: 'numeric' })}`,
    description: `Analysis of budget performance and efficiency for ${new Date(year, month - 1).toLocaleString('default', { month: 'long', year: 'numeric' })}`,
    period: {
      startDate,
      endDate,
      periodType: 'Monthly'
    },
    data: {
      totalExpenses: summary.totalSpent,
      budgetAnalysis: summary.budgets,
      customMetrics: [
        { label: 'Budget Efficiency', value: efficiency, type: 'text' },
        { label: 'Overall Utilization', value: summary.utilizationPercentage, type: 'percentage' },
        { label: 'Categories Over Budget', value: summary.overBudgetCount, type: 'number' },
        { label: 'Categories with Warnings', value: summary.warningCount, type: 'number' }
      ]
    },
    isAutoGenerated: true
  });
  
  // Add insights based on performance
  if (summary.overBudgetCount > 0) {
    report.insights.push({
      type: 'warning',
      title: 'Budget Exceeded',
      message: `${summary.overBudgetCount} categories exceeded their budgets this month`,
      recommendation: 'Consider reviewing and adjusting your budgets or reducing expenses in these categories'
    });
  }
  
  if (efficiency === 'Excellent') {
    report.insights.push({
      type: 'positive',
      title: 'Excellent Budget Management',
      message: 'Your budget utilization is optimal',
      recommendation: 'Keep up the great work with your spending discipline'
    });
  }
  
  return report.save();
};

// Static method to cleanup old reports
reportSchema.statics.cleanupOld = function(daysOld = 90) {
  const cutoffDate = new Date(Date.now() - daysOld * 24 * 60 * 60 * 1000);
  return this.deleteMany({ 
    createdAt: { $lt: cutoffDate },
    isAutoGenerated: true 
  });
};

module.exports = mongoose.model('Report', reportSchema);